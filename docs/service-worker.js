const swFolder=location.pathname.replace(/[^\/]+\.js$/,""),indexUrl=location.origin+swFolder,urlRoot=location.origin+"/",CACHE_NAME="offline";let devLog=()=>{};function wait(e){return new Promise(t=>setTimeout(t,e))}indexUrl.includes("localhost")&&(devLog=console.log),console.log({swFolder:swFolder,indexUrl:indexUrl,urlRoot:urlRoot}),self.addEventListener("install",function(e){devLog("begin install",e,location),e.waitUntil(Promise.all([self.skipWaiting(),intelegentFetch(indexUrl)]))}),self.addEventListener("activate",function(e){devLog("activate",e),e.waitUntil(clients.claim())}),self.addEventListener("fetch",function(e){devLog("fetch",e),e.respondWith(intelegentFetch(e.request))});class LinkedList{constructor(){this.start=void 0,this.end=void 0,this.length=0}get first(){return this.start}get last(){return this.end}set first(e){return this.start=e}set last(e){return this.end=e}add(e){const t=createLinkedItem(this,e);return this.start||(this.start=t),this.end?(t.prev=this.end,this.end.next=t,this.end=t):this.end=t,this.length++,t}}function createLinkedItem(e,t={}){let n;return n="object"!=typeof t?Object.create({data:t}):Object.create(t),n.next=void 0,n.prev=void 0,n.get=function(e){return t[e]},n.drop=function(){n.next&&(n.next.prev=n.prev),n.prev&&(n.prev.next=n.next),e.start===n&&(e.start=n.next),e.end===n&&(e.end=n.prev),e.length--},n}const currentlyOngoingCalls=new LinkedList;async function intelegentFetch(e,t=!1){let n,i=e.url||e;if(i.includes("://")&&!i.startsWith("http"))return fetch(e);const o=await caches.open("offline");if(t&&(n=await o.match(e),n))return n;let r;if(n=await o.match(e)){let t=n.headers.get("etag"),o=n.headers.get("last-modified"),a=n.headers.get("Date");if(r=await n.clone().text(),r){let r,s=0,d=2;for(devLog(`Execution for ${i}: Start HEAD loop`);!r&&s<d;){s++;let d=200*s;try{devLog(`HEAD ${i}: there are currently ${currentlyOngoingCalls.length} other ongoing other fetches`);let t=fetch(e,{method:"HEAD"}),n=currentlyOngoingCalls.add(t);r=await t,n.drop()}catch(e){return devLog(`Execution for ${i}: Exit HEAD on error`),r=void 0,n}if(!r.ok||r.status>=300||r.status<200)devLog(`Execution for ${i}: Retry HEAD on bad status`),r=void 0,await wait(d);else if(r&&r.headers){if(t&&r.headers.get("etag")===t)return devLog(`Execution for ${i}: Exit HEAD on etag equivilance`),n;if(o&&r.headers.get("last-modified")===o)return devLog(`Execution for ${i}: Exit HEAD on last-modified equivilance`),n;if(a&&r.headers.get("Date")===a)return devLog(`Execution for ${i}: Exit HEAD on Date equivilance`),n;devLog(`Execution for ${i}: HEAD Header Data:`,{etag:r.headers.get("etag"),"last-modified":r.headers.get("last-modified"),date:r.headers.get("date")}),r.headers.forEach((e,t)=>{devLog(`Execution for ${i}: HEAD Header ${t}: ${e}`)})}else devLog(`Execution for ${i}: Retry HEAD on lack of header response`)}if(devLog(`Execution for ${i}: End HEAD loop.`,{cachedEtag:t,cachedLastMod:o,cachedDate:a}),s>=d)return devLog(`Execution for ${i}: Exit HEAD on max-attempt reached`,{attempts:s,maxAttempts:d}),n;devLog(`Execution for ${i}: Passed attempts check`)}devLog("asset needs refreshing",e)}let a,s=0;for(;!a&&s<3;){s++;let t=200*s;try{devLog(`GET ${i}: there are currently ${currentlyOngoingCalls.length} other ongoing other fetches`);let t=fetch(e),n=currentlyOngoingCalls.add(t);a=await t,n.drop()}catch(e){a=void 0,await wait(t);continue}if(!a.ok||a.status>=300||a.status<200)a=void 0,await wait(t);else{if(await a.clone().text())return await o.put(e,a.clone()),a;a=void 0,await wait(t)}}return a||n}